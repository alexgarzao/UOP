#include <iostream>

#include "ubibindLexer.h"
#include "ubibindParser.h"

#include "UbibindDefs.hpp"

static pubibindLexer lxr;

static void parseFile   (SParamOptions options);


void showVersion() {
   std::cerr << "UbiBind 0.1.0" << std::endl;
}

void showSyntax(int valor) {
    std::cout << "Use: ubibind [options] filename" << std::endl;
    std::cout << "\t-o\tDefine output filename." << std::endl;
    std::cout << "\t-h\tShow this help." << std::endl;
    std::cout << "\t-v\tShow version." << std::endl;
    std::cout << std::endl;
    std::cout << "To report bugs: alexgarzao@gmail.com " << std::endl;

    exit(valor);
}



// Main entry point for this example
//
int ANTLR3_CDECL main(int argc, char *argv[])
{
	showVersion();

	SParamOptions options;

	int param;
	while ((param = getopt(argc, argv, "o:hv")) != -1) {
		switch (param) {
			case 'o': // Output filename
				options.outputFilename = std::string(optarg);
				break;
			case 'v': // Version
				exit(1);
				break;
			case 'h': // Help
				showSyntax(1);
				break;
			default: // Other options
				showSyntax(1);
				break;
		}
	}

	argc -= optind;
	argv += optind;

    if (argc == 0) {
        std::cerr << "Error: Undefined filename..." << std::endl;
        showSyntax(EXIT_FAILURE);
    }

    options.sourceFilename = std::string(argv[0]);
	if (options.outputFilename.empty()) {
		options.outputFilename = std::string("uvm_os_") + options.sourceFilename.substr(0, options.sourceFilename.find_last_of('.')) + ".cpp";
	}

	parseFile(options);

    printf("finished parsing OK\n");	// Finnish parking is pretty good - I think it is all the snow

    return EXIT_SUCCESS;
}


static void
parseFile(SParamOptions options)
{
    pANTLR3_INPUT_STREAM    input;
    pANTLR3_COMMON_TOKEN_STREAM	    tstream;
    pubibindParser				psr;
    pANTLR3_UINT8 fName = (pANTLR3_UINT8)options.sourceFilename.c_str();
    input	= antlr3AsciiFileStreamNew(fName);

    if ( input == NULL )
    {
		fprintf(stderr, "File not found: %s\n", (char *)fName);
	    exit(1);
    }

    if (lxr == NULL)
    {
		lxr = ubibindLexerNew(input);	    // javaLexerNew is generated by ANTLR
    }
	else
	{
		lxr->pLexer->setCharStream(lxr->pLexer, input);
	}

    // Need to check for errors
    //
    if (lxr == NULL)
    {
	    fprintf(stderr, "Unable to create the lexer due to malloc() failure1\n");
	    exit(ANTLR3_ERR_NOMEM);
    }

    tstream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));

    if (tstream == NULL)
    {
		fprintf(stderr, "Out of memory trying to allocate token stream\n");
		exit(ANTLR3_ERR_NOMEM);
    }

    // Finally, now that we have our lexer constructed, we can create the parser
    //
    psr = ubibindParserNew(tstream);  // javaParserNew is generated by ANTLR3

    if (tstream == NULL)
    {
		fprintf(stderr, "Out of memory trying to allocate parser\n");
		exit(ANTLR3_ERR_NOMEM);
    }

    tstream->tstream->_LT(tstream->tstream, 1);	// Don't do this normally, just causes lexer to run for timings here
    psr->compilation_unit(psr, options);
    putc('*', stdout); fflush(stdout);

    // We did not return anything from this parser rule, so we can finish. It only remains
    // to close down our open objects, in the reverse order we created them
    //
	psr    ->free (psr);     psr     = NULL;
	tstream->free (tstream); tstream = NULL;
	lxr    ->free (lxr);     lxr     = NULL;
	input  ->close(input);   input   = NULL;
}
